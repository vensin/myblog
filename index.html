

<html lang="">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />

  <meta name="theme-color" content="#42dbbc" />
  <meta name="msapplication-navbutton-color" content="#f8f5ec" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec" />

  
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/myblog/images/favicon.ico" />
  

  <title>Vensin</title>

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">

  
    <link rel="stylesheet" type="text/css" href="/myblog/lib/fancybox/jquery.fancybox.css" />
  

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

  <link rel="stylesheet" href="/myblog/css/style.css">

  

  <script>
    window.config = {"title":"Vensin","subtitle":"About Me","description":"所有的相遇都是久别重逢","author":"Vensin","language":null,"timezone":null,"url":"http://vensin.github.io/myblog","root":"/myblog/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":"atom-one-light","default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"cicada","deploy":{"type":"git","repo":"https://github.com/vensin/myblog.git","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"favicon":"/images/favicon.ico","menu":{"home":"/","archives":"/archives"},"show_tag":true,"show_category":false,"excerpt_link":"Read More","fancybox":true,"disqus_shortname":null,"rss":"default","social":{"email":"dasd","instagram":"dasd","douban":"das","linkedin":"dsa","weibo":null,"stackoverflow":null,"facebook":null,"twitter":null,"github":null,"google":null,"zhihu":null,"pocket":null},"friends":{"Mos's Blog":"https://kexin-li.github.io"},"google_analytics":null,"portfolio":{"subtitle":"Some Works","cards":{"card1":{"cover":"/images/screenshot.png","content":"Cicada is a concise and retro Hexo theme.","link":"https://github.com/Kexin-Li/hexo-theme-cicada"},"card2":{"cover":"/images/screenshot.png","content":"Cicada is a Hexo theme, it tastes like summer.","link":"http://kexin-li.github.io"},"card3":{"cover":"/images/screenshot.png","content":"Cicada is a Hexo theme, it tastes like summer.","link":"http://kexin-li.github.io"}}},"about":null,"poem":false};
  </script>
</head>
  <body>
    

<header class="blog-slide" style="height: px">
  <nav class="blog-header">
    <a class="mobile toggle-button"><i class="fas fa-bars fa-lg"></i></a>
    <ul>
      <li class="title"><a href="/">Vensin</a></li>
      
        <li class="nav-item"><a href="/myblog/">Home</a></li>
      
        <li class="nav-item"><a href="/myblog/archives">Archives</a></li>
      
    </ul>
  </nav>
  <h1 class="subtitle"><span id='jinrishici-sentence'>犹豫就会败北</span></h1>
</header>
    <nav id="menu">
  
    <a href="/myblog/">Home</a>
  
    <a href="/myblog/archives">Archives</a>
  
</nav>
    
    <main class="blog-main" style="margin-top: -150px">
      
    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/06/09/计算机网络之运输层/">
        计算机网络——运输层
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>​        从通信和信息处理的角度来看，运输层向它上面的应用层提供通信服务，属于面向通信部分的最高层。同时也是用户功能中的最底层。运输层是为相互通信的进程之间提供逻辑通信。</p>
<p>​        我们知道IP协议就能准确的将信息送到对应IP地址的主机，但是为什么还需要运输层呢？实际上通信是进程与进程的交换数据，到达对应主机后，这个分组还停留在主机的网络层，接下来还需要交付给对应的进程，此时就需要运输层的信息来确定交付给哪个进程。通信的真正端点并不是主机而是<strong>主机中的进程</strong>，也就是<strong>端到端的通信</strong>。</p>
<p>​        通常一个主机会同时运行许多进程，所以运输层有两个很重要的功能——<strong>复用</strong>和<strong>分用</strong>。复用指发送方不同的进程都可以使用同一个运输层传输协议 ，分用则是剥开首部后可以能将数据正确的交付给对应进程。</p>
<p>​        运输层除了为进程提供逻辑通信以外，还有一个重要的功能——<strong>差错检测</strong>。 在网络层，只检测首部是否出现错误而不检测数据部分。 根据应用程序的不同需求，运输层有两个协议，无连接的<strong>UDP</strong>和面向连接的<strong>TCP</strong>。</p>
<p>​        运输层向高层用户屏蔽了下面网络核心的细节，使得应用进程看见的就是一条端到端的逻辑通信信道，但。但因为不同的协议，这条逻辑信道向上层的表现有很大的差别。当运输层采用可靠的TCP协议时，尽管网络层的传输是不可靠的，但是对于应用层来说，他还是一条可靠的全双工通信信道。如果使用的是不可靠的UDP协议，那么这条逻辑信道还是不可靠的。</p>
<h5 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h5><p>TCP/IP运输层的两个主要协议都是互联网的正式标准，即</p>
<ol>
<li><strong>用户数据报协议UDP</strong></li>
<li><strong>传输控制协议TCP</strong></li>
</ol>
<p>按照OSI的术语，两个对等运输实体在通信是传送的数据单位叫做<strong>运输协议数据单元</strong>。但在TCP/IP体系中，根据协议的不同，分别称之为<strong>TCP报文段</strong>，或者<strong>UDP用户数据报</strong>。</p>
<p>​        UDP在传输前不需要建立连接，目的主机收到数据后也不需要给出确认。</p>
<p>​        TCP则提供面向连接的服务。在传送前要建立连接，传输完成后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的传输服务，因此多了许多开销，如确认，流量控制，计时器及连接管理等。</p>
<h5 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h5><p>​        计算机的进程是由进程标识符来标识的，但是不同操作系统的格式又有所不同，因此我们需要一个统一的标识符。但是，把一个机器上的特定进程指定为通信的终点还是不可取的，因为进程的创建和撤销是动态的，另外，我们往往需要利用目的主机提供的功能来识别终点，而不需要知道具体实现这个功能的进程是哪个（例如，要和某个邮件服务器通信，并不需要知道这个服务器功能是由目的主机的哪个进程实现的）。此时需要用运输层的<strong>协议端口号</strong>来解决这个问题。</p>
<p>​        协议端口号是<strong>软件端口</strong>，是<strong>应用层和各种协议进程与运输实体进行层间交互的一种地址</strong>。TCP协议用16为端口号来标志一个端口。端口号只具有本地意义，不同计算机中端口号是没有关联的。</p>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><ol>
<li><p>UDP是<strong>无连接</strong>的</p>
</li>
<li><p>UDP使用<strong>尽最大努力交付</strong></p>
</li>
<li><p>UDP是面向报文的</p>
<p>UDP对于应用层的交下来的报文仅加上首部就交付给网络层，对于网络层交付的文件仅剥掉首部就交付给应用层。</p>
</li>
<li><p>UDP没有拥塞控制</p>
<p>因此网络拥塞不会使得发送速率降低，这对某些应用来说是很重要的。</p>
</li>
<li><p>UDP支持一对一，一对多，多对一和多对多的交互通信。</p>
</li>
<li><p>UDP的首部开销小，只有8个字节。</p>
</li>
</ol>
<h5 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h5><p>用户数据报UDP有两个字段，数据字段和首部字段。首部字段有8个字节，由四个字段组成，每个字段两个字节，分别表示源端口（原端口号，不需要时可全用0），目的端口（在终点交付报文时必须使用），长度（UDP数据报的长度，最小值为8，此时仅有首部），检验和（检测数据报在传输中是否有错）。</p>
<p>​        UDP用户数据报中首部检验和的方法有些特殊。在计算检验和是，要在首部前加上伪首部（由源IP地址，目的IP地址，全0,，17，UDP长度组成），再和UDP数据报一起看成是由许多16位的字串连接起来的。把这些16位数按反码求和，将结果求反码之后写入检验和。</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP是TCP/IP体系中非常复杂的一个协议。</p>
<ol>
<li>TCP是<strong>面向连接</strong>的传输层协议。在数据传输前要建立连接，传输完成后要释放连接。</li>
<li>每条TCP连接只能有<strong>两个端点</strong>。每一条TCP只能是点对点连接的。</li>
<li>TCP提供<strong>可靠交付</strong>的服务。</li>
<li>TCP提供<strong>全双工通信</strong>。</li>
<li><strong>面向字节流</strong>。TCP中的流指的是流入到进程或从进程流出的字节序列。面向字节流的含义是 ，虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的程序看成是一个字节流，可能接收方交付给应用层的数据块数量和发送方不一样（例如发送方应用层交付的数据块是10个，但接收方可能用4个数据块就交付给应用层），但是最终字节流是一样的。</li>
</ol>
<h5 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h5><p>TCP连接的两个端既不是TP地址，也不是运输层的协议端口，而是套接字（socket）或插口。根据RFC 793的定义，端口号拼接到IP地址即构成了套接字，例如192.168.3.2：8808。</p>
<p>每条TCP连接被通信两端的端口唯一的确定。同一个IP地址可以有很多个TCP连接，同一个端口号也可以出现在多个不同的TCP连接中。</p>
<h4 id="可靠传输的原理"><a href="#可靠传输的原理" class="headerlink" title="可靠传输的原理"></a>可靠传输的原理</h4><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><ol>
<li><p>无差错情况</p>
<p>​        发送方A向接收方B发送分组M1，B收到之后向A发送确认，A收到确认后向B发送分组M2，如此循环。</p>
</li>
<li><p>出现差错</p>
<p>​        B在接收M1时可能检测出了 差错，此时B丢弃这个错误分组，并且不发送确认。也可能分组子传输中丢失，此时B无法收到分组，也什么都不做。A只要超过一定时间没有没有收到B的确认，就重新传输前面发出的分组，这叫<strong>超时重传</strong>，要实现超时重传，就要在发出一个分组后设置一个超时计时器。若是在计时器结束之前收到了确认，就撤销该计时器。</p>
<p>这里有三点需要注意的地方：</p>
<p>（1）在发送完一个分组后，必须暂时保留已发出分组的副本，方便超时重传，收到确认后方可丢弃。</p>
<p>（2）对每个分组和分组确认进行编号，这样才能明确发出的分组和收到的确认。</p>
<p>（3）计时器设置的重传时间需要大于在网络中传输的往返时延。</p>
</li>
<li><p>确认丢失和确认迟到</p>
<p>​        假设B对A的M1确认丢失了，A无法在设定的时间内收到，A会分组M1，B再次收到M1后，会再次发送对M1的确认，并且丢弃该重复的M1.</p>
</li>
<li><p>信道利用率</p>
<p>​        停止等待协议的优点是简单，但缺点是信道利用率低。假设A发送分组的时间为TD，B收到分组后处理的时间忽略不计，B发送确认分组的时间为TA，则总的时间为TA+RTT+TA（RTT为往返时间），因此信道利用率可用如下式子计算，<br>$$<br>U=TD/(TD+RTT+TA)<br>$$</p>
</li>
</ol>
<p>当往返时间RTT远大于发送时间时，信道的利用率就会非常低。若出现重传，则对传送有用的数据信息来说，信道的利用率就更低。为了提高传输效率，发送方可用采用流水线传输，即连续发送分组，不必每发完一个分组就听下来等待确认。</p>

        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  <h1 class="post-title">
    Untitled
  </h1>

      
    </div>
    <div class="post-detail">
      
        <h1 id="计算机网络（一）"><a href="#计算机网络（一）" class="headerlink" title="计算机网络（一）"></a>计算机网络（一）</h1><p>​        计算机网络由若干节点和连接这些节点的链路组成。互联网大致可以分成两大块，边缘部分和核心部分。<strong>边缘部分</strong>是由所有连接在互联网上的主机组成，这部分是用户直接使用的。<strong>核心部分</strong>是由大量网络和连接这些网络的路由器组成，为边缘部分提供服务。 </p>
<p>​        我们常说的主机A和主机B通信，通常指的是A上的某个程序和B上的另一个程序在通信，由于“进程”就是运行着的程序，因此就是A上的某个进程和B上的某个进程在通信，简称为<strong>计算机之间通信</strong></p>
<p>​        在网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务端方式（C/S方式）和对等方式（P2P方式）。</p>
<ol>
<li><p>客户-服务端方式</p>
<p>最常用也是最传统的方式。客户端和服务器指通信中的两个进程。客户端想服务器发出请求服务器向客户端提供服务。</p>
</li>
<li><p>-P2P方式</p>
<p>两台主机在通信时并不区分哪个是客户端，哪个是服务器，双方进行平等的，对等的链接通信。</p>
</li>
</ol>
<h5 id="互联网的核心"><a href="#互联网的核心" class="headerlink" title="互联网的核心"></a>互联网的核心</h5><p>​        在网络核心起特殊作用的是路由器。路由器是一种特殊的计算机，是实现分组交换的重要部件，用于在网络中转发分组。</p>
<p>​        在了解分组交换之前，先介绍电路交换。在实现打电话时，电话两两相连是不现实的，因此，要把所有的电话都接到交换机上。当电话机的数量增多，使用很多交换机来完成全网的交换任务，这样就构成了电信网。</p>
<p>​         </p>
<p>​    </p>

        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/05/05/设计模式之观察者模式/">
        设计模式之观察者模式
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变时，它的所有依赖者都会收到通知并自动更新。</p>

        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/05/05/设计模式之策略模式/">
        设计模式之策略模式
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。</p>
<p>算法族：一组可以互相替换的算法，除具体行为不同外，继承的接口应相同。</p>
<p>设计原则1 ：找出应用中需要变化之处，将他独立出来封装起来，不要和那些不用变化的代码混在一起。</p>
<p>设计原则2：针对<strong>接口</strong>编程，而不是针对<strong>实现</strong>编程。</p>
<p>设计原则3：多用组合，少用继承。</p>

        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/04/21/算法设计与分析（五）/">
        算法设计与分析（五）
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划是一种算法设计技术，当我们的问题是由交叠的子问题构成的，我们就用到这个技术来解决它。例如求解斐波那契数列，第n个元素的值为$F(n)=F(n-1)+F(n-2),n&gt;1$。</p>
<p>一般来说，一个算法如果基于经典的自底向上动态规划方法，那就需要给出子问题的解。动态规划法的一个变化形式是试图避免对不必要的子问题求解。</p>

        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/04/19/算法设计与分析（四）/">
        算法设计与分析（四）
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="变治法"><a href="#变治法" class="headerlink" title="变治法"></a>变治法</h1><p> 变治法有三种主要的类型</p>
<ol>
<li>变换为同样问题的一个更简单的或者更方便的实例——实例化简</li>
<li>变换为同样实例的不同表现——改变表现</li>
<li>变换为另一个问题的实例，这种问题的算法是已知的——问题化简</li>
</ol>

        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/04/19/算法设计与分析（三）/">
        算法设计与分析（三）
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>分治法是按以下方案工作的</p>
<ol>
<li>将一个问题划分为同一类型的若干子问题，子问题最好规模相同。</li>
<li>对这些子问题求解</li>
<li>有必要的话，合并这些子问题的解，以得到原始问题的答案。</li>
</ol>
<h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p>合并排序是成功应用分治技术的一个完美例子。对于一个需要排序的数组，将他一分为二，对每个子数组递归排序，然后将排好序的子数组合并为一个有序数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">算法 	Mergesort(A[0...n-1])</span><br><span class="line"></span><br><span class="line">	//递归调用该算法来对数组进行排序</span><br><span class="line">	//输入：一个可排序数组A[0..n-1]</span><br><span class="line">	//输出：排好序的数组A</span><br><span class="line">	</span><br><span class="line">	if n&gt;1</span><br><span class="line">		copy A[0..(n/2)-1] to B[0..(n/2)-1]</span><br><span class="line">		copy A[n/2...n] to C[0...(n/2)-1]</span><br><span class="line">		Mergesort(B[0...(n/2)-1])</span><br><span class="line">		Mergesort(C[0...(n/2)-1])</span><br><span class="line">		Merge(B,C,A,n)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">算法 Merge(B,C,A,n)</span><br><span class="line">	//输入：排好序的子数组</span><br><span class="line">	//输出：排好序的A数组</span><br><span class="line">	</span><br><span class="line">	i←0,j←0,k←0</span><br><span class="line">	while i&lt;n/2 and j&lt;n/2 do</span><br><span class="line">		if B[i] &lt;= C[j] </span><br><span class="line">			A[k]←B[i]</span><br><span class="line">		else</span><br><span class="line">			A[k]←C[j]</span><br><span class="line">	if i=n/2</span><br><span class="line">		copy C[j..(n/2)-1] to A[k..n-1]</span><br><span class="line">	else</span><br><span class="line">		copy B[j..(n/2)-1] to A[k..n-1]</span><br></pre></td></tr></table></figure>
<p>我们假设n是2的乘方，那么键值比较次数的C(n)的递推关系式为$C(n)=2C(n/2)+Cmerge(n),C(0)=0$</p>
<p>对于Cmerge(n),在最坏情况下，Cmerge(n)=n-1,我们得到下面这个递推式</p>
<p>$C(n)=2C(n/2)+n-1=nlog2n-n+1∈Θ(nlogn)$</p>
<p>合并算法的确定在于需要线性的额外空间、</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种按照元素的值对他们进行划分的算法。划分是对数组中的元素重新进行排序，让A[s]左边的值都小于等于A[s]，右边的值都大于等于A[s].</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">算法 QuickSort(A[r...l])</span><br><span class="line"></span><br><span class="line">if r&lt;l</span><br><span class="line">	s←HoarePartition(A[l...r])</span><br><span class="line">	QuickSort(A[l..s-l]) </span><br><span class="line">	QuickSort(A[s+1...r])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">算法 HoarePartition(A[r...l])</span><br><span class="line">//第一个元素为枢轴，对数组进行划分</span><br><span class="line">//输入：待排序数组</span><br><span class="line">//输出：非降序排序的数组</span><br><span class="line"></span><br><span class="line">p←A[l]</span><br><span class="line">i←l,j←r+1</span><br><span class="line">repeat </span><br><span class="line">	repeat i←i+1 until A[i]&gt;=p</span><br><span class="line">	repeat j←j+1 until A[j]&lt;=p</span><br><span class="line">	swap(A[i],A[j])</span><br><span class="line">until i&gt;=j</span><br><span class="line">swap(A[i],A[j])//撤销最后一次交换</span><br><span class="line">swap(A[l],A[j])</span><br><span class="line">return j;</span><br></pre></td></tr></table></figure>
<p>如果扫描指针交叉了，建立划分之前所执行的键值比较次数是n+1，如果他们相等，则是n。如果所有的分裂点位于数组的中点，那么这就是最优情况。键值比较次数满足下面的递推式</p>
<p>n&gt;1，C(n)=2C(n/2)+n<br>n=1，C(1)=0</p>
<p>求得C(n)∈Θ(nlog2n) </p>
<h2 id="大整数乘法和矩阵乘法"><a href="#大整数乘法和矩阵乘法" class="headerlink" title="大整数乘法和矩阵乘法"></a>大整数乘法和矩阵乘法</h2>
        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/04/16/算法设计与分析（二）/">
        算法设计与分析（二）
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="减治法"><a href="#减治法" class="headerlink" title="减治法"></a>减治法</h1><p> 减治技术利用了一个问题<strong>给定实例的解</strong>和<strong>同样问题较小实例的解</strong>之间的某种关系</p>
<p>。一旦确定了这种关系，我们既可以自顶向下也可以自底向上的来运用该关系。虽然自顶向下会自然的导致出递归算法，但最终还是非递归实现较好。自底向上往往是迭代实现的，从求解问题的一个较小实例开始，该方法有时也称为<strong>增量法</strong>。</p>
<p>减治法有三种主要的变化形式：</p>
<ul>
<li><p>减去一个常量</p>
<p>在减常量的变化形式中，每次迭代算法总是从实例中减去一个相同的常量。一般来说，这个常量为1.例如插入排序。</p>
</li>
<li><p>减去一个常量因子</p>
<p>减常因子意味着在算法的每次迭代中，总是从实例中减去一个相同的常量因子。在大多数应用中，该常量因子等于2.例如求a^n的值，当n为偶数时</p>
</li>
<li><p>减去的规模是可变的  </p>
<p>算法在每次迭代时，规模减小的模式都是不同的。计算最大公约数的欧几里得算法是这种情况的一个很好的例子。该算法基于以下公式<br>$$<br>gcd(m,n)=gcd(n,m modn)<br>$$</p>
</li>
</ul>
<p>虽然等号右边的那些参数总是小于等号左边的参数，但它们既不是以常量也不是以常量因子的方式减小的。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>我们考虑用减一法来对一个数组A[0…n-1]进行排序。</p>
<p>根据该思想，我们假设A[0…n-2]已经有序，接下来只需要把A[n-1]插入即可。我们可以从头到尾扫描A[0…n-2]，直到找到第一个小于或等于A[n-1]的元素，将A[n-1]插入该元素的后面。这种算法被称为直接插入排序或者插入排序。</p>
<p>虽然插入排序很明显是基于递归思想的，但是自底向上的实现这个算法，使用迭代效率会更高。</p>
<p>算法伪代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InsertionSort(A[0...n-1])</span><br><span class="line">for i←1 to n-1 do</span><br><span class="line">	v← A[i]</span><br><span class="line">	j←i-1</span><br><span class="line">	while A[j]&gt;v and j&gt;=0 do</span><br><span class="line">		A[j+1]←A[j]</span><br><span class="line">		j←j-1</span><br><span class="line">	A[j+1]←v</span><br></pre></td></tr></table></figure>
<p>该算法的基本操作为v&gt;A[j],明显该算法的效率依赖于特定的输入。</p>
<p>当输入为一个降序数组时，该算法的效率最低，对于这种输入的键值比较次数是<br>$$<br>C(n)=(n-1)n/2∈Θ(n^2)<br>$$</p>
<p>在最好情况下，也就是数组升序时，该算法效率最高，此时键值比较次数是<br>$$<br>C(n)=n-1∈Θ(n)<br>$$<br>该算法平均效率的精确分析主要基于对无序元素对的研究，这种分析表明，对于随机序列的数组，插入排序的平均比较次数是降序数组的一半，也就是<br>$$<br>C(n)=n^2/4∈Θ(n^2)<br>$$</p>
<h2 id="生成-组合对象的算法"><a href="#生成-组合对象的算法" class="headerlink" title="生成 组合对象的算法"></a>生成 组合对象的算法</h2><h4 id="生成排列"><a href="#生成排列" class="headerlink" title="生成排列"></a>生成排列</h4><ol>
<li><p>每次都从左到右或者从右到左将n插入12…(n-1)的位置中</p>
<p>下面这种做法是有好处的：一开始从右到左插入，然后每处理一个12…(n-1)的新排列时，再调换方向。</p>
<p>例如，n=3时</p>
<p>开始              1</p>
<p>从右到左插入2    12    21</p>
<p>从右到左插入3    123    132    312    </p>
<p>从左到右插入3    321    231    213</p>
<p>这种次序满足所谓的<strong>最小变化要求</strong>，即每一个和前一个元素相比都只是交换了两个元素。</p>
</li>
<li><p>Johnson-Trotter算法</p>
<p>伪代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//实现用来生成排序的算法</span><br><span class="line"></span><br><span class="line">//输入：一个正整数n</span><br><span class="line"></span><br><span class="line">//输出：&#123;1,……，n&#125;所有排列的列表</span><br><span class="line"></span><br><span class="line">将第一个排列初始化为12...n（方向都为左）</span><br><span class="line"></span><br><span class="line">while 存在一个移动元素 do</span><br><span class="line"></span><br><span class="line">  求最大的移动元素k</span><br><span class="line">  </span><br><span class="line">  把k和它箭头指向的相邻元素互换</span><br><span class="line">  </span><br><span class="line">  调转所有大于k的元素的方向</span><br><span class="line">  </span><br><span class="line">  将新排列添加到列表中</span><br></pre></td></tr></table></figure>
<p>这个算法是生成排列最有效地算法之一。该算法的运行时间和排列的数量是才呈正比的，也就是说属于集合Θ(n!)。</p>
</li>
<li><p>字典序生成排列</p>
<p>伪代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//以字典序产生排列</span><br><span class="line"></span><br><span class="line">//输入：一个正整数n</span><br><span class="line"></span><br><span class="line">//输出：在字典序下&#123;1,……，n&#125;所有排列的列表</span><br><span class="line"></span><br><span class="line">初始化第一个排列为12……n</span><br><span class="line"></span><br><span class="line">While 最后一个排列有两个连续升序的元素 do</span><br><span class="line"></span><br><span class="line">找到使得ai&lt;ai+1的最大的i     //ai+1&gt;ai+2&gt;ai+3&gt;……&gt;an</span><br><span class="line"></span><br><span class="line">找到使得ai&lt;aj的最大索引j    //j&gt;=i+1,因为ai&lt;ai+1</span><br><span class="line"></span><br><span class="line">交换ai和aj   //ai+1ai+2……an任保持降序</span><br><span class="line"></span><br><span class="line">将ai+1到an的元素反序</span><br><span class="line"></span><br><span class="line">将这个新排列添加到列表中</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="生成子集"><a href="#生成子集" class="headerlink" title="生成子集"></a>生成子集</h4><p>位串法</p>
<p>位串    000    001    010    011    100    101    110    111</p>
<p>子集    Ø      {a3}       {a2}     {a2,a3}    {a1}    {a1,a3}   {a1,a2} {a1,a2,a3}</p>
<p>该算法以字典序生成子集时，顺序很不自然，我们我们希望以挤压序生成子集。</p>
<p>更有挑战性的问题是，生成满足最小变化要求的算法，下面的二进制反射格雷码满足这个要求。</p>
<p>000 001 011 010 110 111 101 100</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">算法 BRGC(n)</span><br><span class="line"></span><br><span class="line">//递归生成n位的二进制反射格雷码</span><br><span class="line"></span><br><span class="line">//输入：一个正整数n</span><br><span class="line"></span><br><span class="line">//输出：所有长度为n的格雷码位串列表</span><br><span class="line"></span><br><span class="line">if n=1,表L包含位串0和位串1</span><br><span class="line"></span><br><span class="line">else 调用BRGC(n-1)生成长度为n-1的位串列表L1</span><br><span class="line"></span><br><span class="line">把表L1倒序后复制给表L2</span><br><span class="line"></span><br><span class="line">把0加到表L1中的每个位串前面</span><br><span class="line"></span><br><span class="line">把1加到表L2中的每个位串前面</span><br><span class="line"></span><br><span class="line">把表L2添加到表L1后面得到表L</span><br><span class="line"></span><br><span class="line">return L;</span><br></pre></td></tr></table></figure>
<h3 id="减常因子算法"><a href="#减常因子算法" class="headerlink" title="减常因子算法"></a>减常因子算法</h3><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>对于有序数组的查找来说，折半查找是一种性能卓越的算法。</p>
<p>该算法是通过比较查找键和数组中间元素来完成查找工作。如果他们相等，则算法结束，                      </p>

        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/04/16/算法设计与分析（一）/">
        算法设计与分析（一）
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="算法效率分析基础"><a href="#算法效率分析基础" class="headerlink" title="算法效率分析基础"></a>算法效率分析基础</h1><p>“<strong>算法分析</strong>“这一词常用在狭义的技术层面，通常指对算法利用运行时间和储存空间的效率做研究。</p>
<h3 id="分析框架"><a href="#分析框架" class="headerlink" title="分析框架"></a>分析框架</h3><p>时间效率也称<strong>时间复杂度</strong>，指出正在讨论的算法运行的有多快；空间效率也称<strong>空间复杂度</strong>，关心算法需要的额外空间。但随着技术的进步，空间复杂度往往已经不是我们需要关注的重点，所以我们把主要精力集中在时间复杂度上。</p>
<p>在研究算法时，一般以输入的规模n作为参数，构造函数。</p>
<p>在计算运行时间时，我们希望能拥有一个不依赖于特定计算机运行速度等无关因素的度量标准。所以我们应该找出算法中最重要的操作，即基本操作，然后计算他们的运行次数。</p>
<p>算法的<strong>基本操作</strong>一般是最内层循环中最费时的操作，例如排序算法中，大多数都是通过对未排序元素的比较来工作的，那么算法的基本操作就是比较。</p>
<p>这样我们就建立起一个算法时间效率的基本分析框架。对于输入规模为n的算法，我们可以统计他的基本操作次数，来对其效率进行度量。 </p>
<p>我们约定，Cop为特定计算机上一个基础操作执行一次的时间，C(n)则是该算法执行基本操作的次数，那么对于运行时间，我们可以进行以下估算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(n) = Cop * C(n)</span><br></pre></td></tr></table></figure>
<p>对于大规模的数据输入，我们的算法效率分析框架忽略了算法常量，仅关注执行时间的<strong>增长次数</strong>及其常数倍。 </p>
<p><img src="D:\AA前端学习\各种笔记\20160829224932413.png" alt="20160829224932413"></p>
<p>有许多算法的运行时间不仅取决于输入的规模，还取决于特定输入的细节，例如顺序查找算法。假设输入为一个长度为n的数组，当要查找的数x为数组的第一个元素时，算法运行的时间是最短的，当数组的最后一个元素为x或者不存在x时，此时算法的运行时间为最长的。</p>
<p>一个算法的<strong>最差效率</strong>是指当输入规模为n时算法在最坏情况下的效率。<strong>最优效率</strong>指的是指当输入规模为n时算法在最优情况下的效率。但我们发现，无论是最差还是最优效率，都无法提供在”典型”或者”随机”情况下，一个算法的效率，这正是<strong>平均效率</strong>试图提供给我们的信息。</p>
<p>本框架最关心的一点：当算法的输入规模趋近于无穷大时，他的运行时间函数的增长次数。</p>
<h3 id="渐进符号和基本效率类型"><a href="#渐进符号和基本效率类型" class="headerlink" title="渐进符号和基本效率类型"></a>渐进符号和基本效率类型</h3><ul>
<li><p>符号O</p>
<p>表示f(n)增长次数小于或等于g(n)</p>
</li>
<li><p>符号Ω(omega)</p>
<p>表示f(n)增长次数等于g(n)</p>
</li>
<li><p>符号Θ(theta)</p>
<p>表示f(n)增长次数大于或等于g(n)</p>
</li>
</ul>
<p>渐进符号的有用特性：如果t1(n)∈O(g1(n))，t2(n)∈O(g2(n))，那么t1(n)+t2(n)∈O(max{g1(n),g2(n)})</p>
<p>比较增长次数的简便方法：基于对所讨论的两个函数的比率求极限<br>$$<br>lim(n-&gt;∞)t(n)/g(n)=0<br>$$<br>表明t(n)的增长次数比g(n)小。<br>$$<br>lim(n-&gt;∞)t(n)/g(n)=c<br>$$<br>表明t(n)的增长次数等于g(n)。<br>$$<br>lim(n-&gt;∞)t(n)/g(n)=∞<br>$$<br>表明t(n)的增长次数大于g(n)。</p>
<p><strong>基本的效率类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>常量</td>
<td>为数很少的效率最高的算法</td>
</tr>
<tr>
<td>logn</td>
<td>对数</td>
<td>算法的每一次循环都会消去问题规模的一个常数因子</td>
</tr>
<tr>
<td>n</td>
<td>线性</td>
<td>扫描规模为n的列表的算法属于这个类型</td>
</tr>
<tr>
<td>n logn</td>
<td>线性对数</td>
<td>许多分治算法，包括合并排序和快速排序的平均效率</td>
</tr>
<tr>
<td>n^2</td>
<td>平方</td>
<td>一般来说，这是包含两重嵌套循环算法的典型效率</td>
</tr>
<tr>
<td>n^3</td>
<td>立方</td>
<td>一般来说，这是包含三重嵌套循环算法的典型效率</td>
</tr>
<tr>
<td>2^n</td>
<td>指数</td>
<td>求n个元素集合的所有子集的算法是这种类型的典型例子</td>
</tr>
<tr>
<td>n!</td>
<td>阶乘</td>
<td>求n个元素集合的完全排列的算法是这种类型的典型例子</td>
</tr>
</tbody>
</table>
<h3 id="非递归算法的数学分析"><a href="#非递归算法的数学分析" class="headerlink" title="非递归算法的数学分析"></a>非递归算法的数学分析</h3><p><strong>分析非递归算法的通用方案</strong></p>
<ol>
<li>决定用哪个参数表示输入规模</li>
<li>找出基本操作</li>
<li>检查基本操作的执行次数是否只依赖于<strong>输入规模</strong>。如果还依赖于一些其他的特性，则最差，最优，平均效率需要分别研究。</li>
<li>建立一个算法基本操作执行次数的基本求和表达式。</li>
<li>利用求和运算的标准公式和法则来建立一个操作次数的闭合公式，或者至少确定他的增长次数。</li>
</ol>
<h3 id="递归算法的数学分析"><a href="#递归算法的数学分析" class="headerlink" title="递归算法的数学分析"></a>递归算法的数学分析</h3><p>用一个例子作为开始，对于任意的非负整数n，用递归计算n的阶乘。</p>
<p>因为当n&gt;=1时，F(n)=1+2+…+n,且0!=1。</p>
<p>所以我们可以用F(n)=F(n-1)+n来计算n的阶乘。</p>
<p>我们以输入的n来表示输入规模，该算法的基本操作是乘法，我们把它的执行次数记做M(n)，所以M(n)满足这个等式<br>$$<br>M(n)=M(n-1)+1,n&gt;0<br>$$<br>这个等式定义了需要求值的M(n)的序列。这种等式称为<strong>递推关系</strong>，或者简称<strong>递推式</strong>。</p>
<p><em>注意：这个等式没有将M(n)定义为n的函数，而是定义成它本身在另一点上的值的函数。也就是说M(n)不是关于n的函数，而是关于M(n-1)的函数。</em></p>
<p>我们的目标是要解递推式，将M(n)转化为关于n的函数。然而满足这个公式的不止一个序列，因此我们还需要一个<strong>初始条件</strong>。要得到初始条件，可以观察算法停止递归调用的条件。</p>
<p>在本题中，我们可以看到当n=0时，不执行乘法操作 。所以，我们遵循的初始条件是<br>$$<br>M(0)=0<br>$$<br>我们用反向替换法来解这个递推式<br>$$<br>M(n)=M(n-1)+1<br>    =M(n-2)+2<br>    =…<br>    =M(n-n)+n<br>    =M(0)+n<br>    =n<br>$$<br>分析递归算法时间效率的通用方案</p>
<ol>
<li>决定用哪个参数表示输入规模</li>
<li>找出基本操作</li>
<li>检查基本操作的执行次数是否只依赖于<strong>输入规模</strong>。如果还依赖于一些其他的特性，则最差，最优，平均效率需要分别研究。</li>
<li>建立一个递推式以及相应的初始条件</li>
<li>解这个递推式，或者至少确定它的解的增长次数</li>
</ol>

        <hr>
      
    </div>

    

    
  </div>
</article>


    <article class="blog-post">
  

  <div class="post-content">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/myblog/2019/01/26/JS模式笔记2/">
        JS模式学习笔记2
      </a>
    </h1>
  

      
    </div>
    <div class="post-detail">
      
        <h1 id="JS模式学习笔记"><a href="#JS模式学习笔记" class="headerlink" title="JS模式学习笔记"></a>JS模式学习笔记</h1><h4 id="字面量和构造函数"><a href="#字面量和构造函数" class="headerlink" title="字面量和构造函数"></a><em>字面量和构造函数</em></h4><h5 id="对象字面量和语法"><a href="#对象字面量和语法" class="headerlink" title="对象字面量和语法"></a>对象字面量和语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var man =&#123;</span><br><span class="line">  head :1,</span><br><span class="line">  body :1,</span><br><span class="line">  hands :2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>注意：</em>对象中以逗号分隔属性和方法，在最后的尾随逗号是允许的，但在IE浏览器中会产生错误，因此尽量不要使用。</p>
<p>在给变量赋值时，别忘了最后的分号。</p>
<h5 id="解决没有使用NEW的方法"><a href="#解决没有使用NEW的方法" class="headerlink" title="解决没有使用NEW的方法"></a>解决没有使用NEW的方法</h5><ul>
<li><p>构造函数命名使用大驼峰</p>
</li>
<li><p>使用that</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">	var that =&#123;&#125;;</span><br><span class="line">	that.sex = &quot;man&quot;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自调用构造函数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    if(!(this instanceof Person)&#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//或者</span><br><span class="line">function Person()&#123;</span><br><span class="line">    if(!(this instanceof arguments.callee)&#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array(&quot;head&quot;,&quot;hand&quot;,&quot;body&quot;);//不建议使用</span><br><span class="line">var b = [&quot;head&quot;,&quot;hand&quot;,&quot;body&quot;];//建议使用</span><br></pre></td></tr></table></figure>
<p>使用数组字面量的另一个理由是避免构造函数中可能产生的陷阱。</p>
<p>当向构造函数传递一个参数时，它并不会成为数组的第一个元素，而是会成为数组的长度。如果向构造函数传递一个浮点数，情况会更加糟糕。</p>
<h5 id="检查数组对象"><a href="#检查数组对象" class="headerlink" title="检查数组对象"></a>检查数组对象</h5><p>以数组为操作符使用typeof时会返回object。</p>
<p>通常需要知道某一个值是否为一个数组，可以检查代码是否有一些属性或者方法，比如lenght或者slice()方法。但是这些检查机制并不健壮。另外可以使用instanceof Array进行检查，但这种在某些IE浏览器版本中不同框架中运行并不正确。</p>
<p>ECMA5定义了一个新方法<code>Array.isArray()</code>,该函数在参数为数组时返回true。</p>
<p>如果当前环境不能使用isArray,还可以通过调用<code>Object.prototype.toString()</code>方法对其检查:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(typeof Array.isArray() === &quot;undefined&quot;)&#123;</span><br><span class="line"> 		Array.isArray = function (arg) &#123;</span><br><span class="line"> 			return Object.prototype.toString.call(arg) === &quot;[object Array]&quot;;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>Javascript Object Notation</p>
<p>在JSON字符串中，不能使用函数或者正则表达式字面量。<em>（为啥）</em></p>
<p>使用<code>JSON.parse()</code>来解析字符串安全性会更好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var jstr = &apos;&#123;&quot;mykey&quot;: &quot;my value&quot;&#125;&apos;;</span><br><span class="line">var data = eval(&apos;(&apos;+jstr+&apos;)&apos;);//反模式</span><br></pre></td></tr></table></figure>
<p>与prase相对应的还有<code>JSON.stringify()</code>。可以将任意的对象或数组（或基本数据类型）序列化为一个字符串。</p>
<h5 id="正则表达式字面量"><a href="#正则表达式字面量" class="headerlink" title="正则表达式字面量"></a>正则表达式字面量</h5><p>JS中正则表达式也是对象，可以用两种方式创造正则表达式</p>
<ul>
<li>使用<code>new RegExp()</code>构造函数</li>
<li>使用正则表达式字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//字面量</span><br><span class="line">var re = /\\/gm;</span><br><span class="line"></span><br><span class="line">//构造函数</span><br><span class="line">var re = new RegExp(&quot;\\\\&quot;,&quot;gm&quot;);</span><br></pre></td></tr></table></figure>
<p>字面量方式更加简洁，并且不要求按照类似类的构造函数方式思考。因此，建议优先使用字面量模式。</p>
<h5 id="正则表达式字面量语法"><a href="#正则表达式字面量语法" class="headerlink" title="正则表达式字面量语法"></a>正则表达式字面量语法</h5><p>正则表达式字面量使用了斜杠来包装用于匹配的正则表达式模式。在第二个斜杠后，可以将该模式修改为不加引号的字母形式</p>
<ul>
<li>g——-全局匹配</li>
<li>m——多行</li>
<li>i——–大小写敏感的匹配</li>
</ul>
<p>模式修改器可以以任何顺序或者组合方式出现：<code>var re = /pattern/gmi;</code></p>
<p>当调用类似String.prototype.replace()的方法以接受正则表达式对象作为参数是，使用正则表达式字面量有利于编写出更简洁的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var l = &quot;abc123CY&quot;.replace(/[a-z]/gi,&quot;&quot;);</span><br><span class="line">console.log(l);//输出123</span><br></pre></td></tr></table></figure>
<p>使用new RegExp的原因之一在于，某些场景中无法事先确定模式，而只能在运行时以字符串的方式创建。</p>
<p>正则表达式字面量和构造函数的一个区别在于，字面量在解析是只有一次创建了变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getRe()&#123;</span><br><span class="line">	var re = /[a-z]/;</span><br><span class="line">	re.foo = &quot;bar&quot;;</span><br><span class="line">	return re;</span><br><span class="line">&#125;</span><br><span class="line">var r1 = getRe(),</span><br><span class="line">	r2 = getRe();</span><br><span class="line">console.log(r1==r2);//输出true，更改之后为false</span><br></pre></td></tr></table></figure>
<p><strong>不过这种行为在ES5中已经得到了改变，并且字面量会创造新的对象。</strong></p>
<h5 id="基本值类型包装器"><a href="#基本值类型包装器" class="headerlink" title="基本值类型包装器"></a>基本值类型包装器</h5><p>JS中六个基本的值类型，Number,String,Boolean,Symbol,undefined,null。</p>
<p>其中除了null和undefined，其他的具有所谓的基本包装对象。可以使用内置构造函数构造，例如<code>new Number();</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var n= 100;</span><br><span class="line">console.log(typeof n);//number</span><br><span class="line">var m = new Number(100);</span><br><span class="line">console.log(typeof m);//object</span><br></pre></td></tr></table></figure>
<p>包装类型和基本类型的差别就在于包装类型有内置的方法，但是基本类型也可以使用这些方法，它们会被临时转换为对象并使用这些方法。</p>
<p>一般包装类型是在需要添加额外的属性时使用，基本类型不是对象，不能添加属性。</p>
<p><strong>当没有使用New时，包装构造函数将传递给它们的值转换成一个基本类型。</strong></p>
<h5 id="错误对象"><a href="#错误对象" class="headerlink" title="错误对象"></a>错误对象</h5><p>JS中有一些内置错误对象构造函数，比如Error(),SyntaxError().这些错误构造函数都带有throw语句。通过这些错误构造函数创建的错误对象都有以下属性：</p>
<p>name:</p>
<p>​    用于创建对象的构造函数的名称属性，可以是一般的”Error”或者更为专门的构造函数，比如”RangeError”。</p>
<p>message:</p>
<p>​    创建对象是传递给构造函数的字符串。</p>
<p>错误对象也还有一些其他的属性，例如发生错误的行号和文件名，但这些额外信息都是浏览器的扩展属性，在多个浏览器实现中并不一致。</p>
<p>throw适用于任何对象，因此可以选择抛出自己的对象，这种错误对象也可以有属性”name”,”message”,以及任何希望传递给catch语句来处理的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	throw&#123;</span><br><span class="line">		name : &quot;myError&quot;,</span><br><span class="line">		message : &quot;opps&quot;,</span><br><span class="line">		extra: &quot; &quot;,</span><br><span class="line">		remedy: genericErrorHandler</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">	alert(e.message);</span><br><span class="line">	e.remedy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        <hr>
      
    </div>

    

    
  </div>
</article>




<nav class="blog-pager">
  
  
    <a class="next" href="/myblog/page/2/">next<i class="fas fa-angle-right"></i></a>
  
</nav>

    </main>
    
    <div class="back-to-top" id="back-to-top"><i class="fas fa-arrow-alt-circle-up fa-2x"></i></div>

    <footer class="blog-footer">
  


<hr>
<div class="blog-footer-friends">
  <p class="title">FRIENDS</p>
  <div class="friends">
  
    <a href="https://kexin-li.github.io" target="_blank">Mos&#39;s Blog</a>
  
  </div>
</div>

  


  <div class="blog-footer-social">
    <ul>
      
        
          <li><a class="iconfont icon-email" href="mailto:dasd"></a></li>
        
      
        
          <li><a class="iconfont icon-instagram" href="dasd"></a></li>
        
      
        
          <li><a class="iconfont icon-douban" href="das"></a></li>
        
      
        
          <li><a class="iconfont icon-linkedin" href="dsa"></a></li>
        
      
      
        
        <li><a class="iconfont icon-rss" href="/myblog/atom.xml"></a></li>
      
    </ul>
  </div>
 
  <div class="blog-footer-copyright">
  <p class="copyright">Copyright © 2018 Vensin. Powered by <a href="https://hexo.io/">Hexo</a> and <a href="https://github.com/Kexin-Li/hexo-theme-cicada">Cicada</a>. <iframe src="https://ghbtns.com/github-btn.html?user=Kexin-Li&repo=hexo-theme-cicada&type=star&count=false&size=small" frameborder="0" scrolling="0" width="58px" height="30px" style="margin-bottom: -15px"></iframe></p>
</div>
</footer>

<script type="text/javascript" src="/myblog/lib/jquery/jquery.min.js"></script>


  <script type="text/javascript" src="/myblog/lib/fancybox/jquery.fancybox.pack.js"></script>


<!--  -->




<script type="text/javascript" src="/myblog/js/cicada.js"></script>
  </body>
</html>